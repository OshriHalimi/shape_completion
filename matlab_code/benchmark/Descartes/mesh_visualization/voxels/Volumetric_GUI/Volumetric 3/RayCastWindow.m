function [  ] = RayCastWindow( pos, DataStruct, GetCamProperties, rez, shadingInfo )
%RAYTRACEWINDOW Summary of this function goes here
%   Detailed explanation goes here
    
    
    

    %INITIALIZE
    rez = rez;
    sampleNum = 200;
    sampleChunk = 200;
    shadingLevel = shadingInfo.level;
    shadingCont = shadingInfo.cont*50;
    
    % Default
    % Chosen so angle of incidence will be different for all planes that
    % will typically be generated by box mask layers.
    temp = load('GlobalSettings.mat');
    lightDir = temp.GlobalSettings.lightDir; 
    lightDir = lightDir/norm(lightDir); 
    shadingSmooth = temp.GlobalSettings.shadingSmooth;
    %lightDir = [1,1,1]/norm([1 1 1]); 
    
    method = {'linear','cubic', 'nearest'};
    method = method{2};
    
    
    height = rez;
    width = rez;
    
    scr = get(0,'ScreenSize');
    
    pos = [ 400+100+600 (scr(4)-height)];

    title = 'Ray Cast Render';
    
    fig = figure('Name',title, 'Resize', 'on', 'MenuBar', 'None', 'NumberTitle', 'off', 'Position', [pos(1) pos(2) width height]);  % 'CloseRequestFcn', @MyCloseRequestFcn, 'DeleteFcn', @MyDeleteFcn);
    set(fig, 'Color', 'black');
    set(fig, 'Resize', 'off');

    
    
    % create the view axes
    sX = 1;
    sY = 1;
    spX = 0;
    spY = 0;
    
    viewAxis = axes('Parent', fig, 'Units', 'Normalized', 'Position', [ spX, spY, sX, sY]);
    
    
    % create the image object
    defaultIm(:,:,1) = [1,2; 3,4]/4;
    defaultIm(:,:,2) = [4,1; 2,3]/4;
    defaultIm(:,:,3) = [3,4; 1,2]/4;
    
    imageHandle = image(zeros(size(defaultIm)), 'Parent', viewAxis);
    set(imageHandle,'cdata', defaultIm)
    set(viewAxis, 'XTick', [], 'YTick', [], 'ZTick', []);
    set(viewAxis, 'color', 'black');
    
    sX = .4;
    sY = .05;
    spX = 0;
    spY = .95;
    textDisp = uicontrol('Parent', fig, 'Style', 'Text', 'Units', 'Normalized', 'Position', [ spX, spY, sX, sY]);
    set(textDisp, 'String', 'Wait', 'FontSize', 12, 'ForegroundColor', 'white', 'BackgroundColor', 'black');

    
    
    % Build the fully specified color matrix (Make sure to delete it on
    % window closing
    %DataStruct.Master.Alpha % empty is shorthand for do not render
    %DataStruct.Master.Color
    %DataStruct.Master.VolIndexAlpha;
    %DataStruct.Master.VolIndexColor;
    
    DataStruct.Master.Alpha;
    DataStruct.Master.Color;
    
    sizeCol = size(DataStruct.Master.VolIndexColor);
    sizeVol = sizeCol(1:3);
    volCA = zeros([ sizeVol 4]);
    
    % Setup the volume of colors and alphas
    volCA(:,:,:,1) = reshape( DataStruct.Master.Color(DataStruct.Master.VolIndexColor,1), sizeCol(1:3) );
    volCA(:,:,:,2) = reshape( DataStruct.Master.Color(DataStruct.Master.VolIndexColor,2), sizeCol(1:3) );
    volCA(:,:,:,3) = reshape( DataStruct.Master.Color(DataStruct.Master.VolIndexColor,3), sizeCol(1:3) );
    
    volCA(:,:,:,4) = reshape( DataStruct.Master.Alpha(DataStruct.Master.VolIndexAlpha,1), sizeCol(1:3) );
    
    [xCrop, yCrop, zCrop] = Crop3(DataStruct.Master.VolIndexAlpha);
    
    volCA = volCA(xCrop,yCrop,zCrop,:);
    
    volCA = permute(volCA, [2 1 3 4]);
   
    % In order to make shaded surfaces smoother this seems nescessary right
    % now.
    if shadingLevel>0&&strcmp(shadingSmooth,'yes')
        volCA(:,:,:,4) = smooth3(volCA(:,:,:,4));
    end
        
    % Update for cropped version
    sizeVol = size( squeeze(volCA(:,:,:,4)));
    sizeVol = sizeVol([2,1,3]);
    
    
    % Build camera model and Get samples for each pixel
    [camPos, volCenter, camAngle, camUp, camFor] = GetCamProperties();
    
    % Adjust these values to compensate for descrepancy between sizes
    % keeping in mind that the 3D preview may be cropped..
    newVolCenter = sizeVol/2;
                              %*(mean(newVolCenter)/mean(volCenter))
    camPos = (camPos-volCenter)*(1.0)+newVolCenter;
    %camRight = cross([0, 0, 1], camFor);
    
    
    % CHECK TO SEE IF CAMUP ACTUALLY POINTS UP FOR CAMERA OR IF IT ONLY
    % POINTS UP AS IN TO INDICATE X is up Y is up or Z is UP?
    % THIS WILL SKEW THE RENDERING IF IT IS THE CASE, and WE WILL NEED TO
    % CALCULATE CAM UP ON OUR OWN. which is not too bad.
    
    camRight = cross(camUp, camFor);
    camRight = camRight/norm(camRight);
    
    camToCentDist = norm(camPos-volCenter);
    
    
    
    fullImage = zeros(rez, rez, 3);
    
    pixCur = 0;
    pixNum = rez*rez;
    
    
    % center samples at object, then sample around that distance,
    % preferable only over the total depth of the object.
    % YAY THIS WORKS SO WELL !!!!!!
    sampleDists = camToCentDist + ((1:sampleNum)/sampleNum-.5)*(max(sizeVol)*1.1);
    
    startPos = ones(size(sampleDists'))*camPos;
    
    %raySamplePoints = zeros(sampleNum, 3);
    
    
    
    % Perform the interpolation sampling
    
    fullImage(:,:,:) = ones(rez,rez,3)*.2;
    
    chunk = 1;
    totalChunks = (rez.^2)/(sampleChunk.^2);
    
    rayAlpha = zeros(sampleNum, sampleChunk, sampleChunk, 1);
    
    % do interps in chunks
    % here x and y refer to pixels
    for x1=1:sampleChunk:(rez)
        for y1=1:sampleChunk:(rez)
            
            
            x2 = x1+sampleChunk-1;
            y2 = y1+sampleChunk-1;
            
            
            raySampleGrid = zeros(sampleNum, 3, sampleChunk,sampleChunk);
    
            % Build up the sample points for a chunk
            % Here x and y refer to actual positions in the image, whereas xi and
            % yi refer to image pixels
            set(textDisp, 'string', ['Rays Chunk ' num2str(chunk) '/' num2str(totalChunks)])
            pause(.001)
            
            for y= y1:y2

                for x= x1:x2

                    % find pixel forward vec
                    [pForVec] = getPixelForVec(x,y);

                    raySamplePoints = startPos  + sampleDists'*pForVec;

                    xi = x; %ceil(x*ratio);
                    yi = y; %ceil(y*ratio);
                    xRl = xi-x1+1; % position relative to chunk
                    yRl = yi-y1+1;
                    raySampleGrid(:,:,xRl,yRl) = raySamplePoints;

                    pixCur = pixCur+1;

                    %clear('raySamplePoints');

                end
                

            end
            
            % Used for computing shading effects
            raySampleGrid2 = [];
            if shadingLevel>0
                raySampleGrid2 = raySampleGrid + repmat(lightDir, [sampleNum 1 sampleChunk sampleChunk])*1; 
            end
            
           
            rayAlpha(:,:,:,1) = squeeze(interp3(volCA(:,:,:,4),raySampleGrid(:,1,:,:),raySampleGrid(:,2,:,:),raySampleGrid(:,3,:,:), method, 0));
            
            rayAlpha2 = [];
            if shadingLevel>0
                rayAlpha2(:,:,:,1) = squeeze(interp3(volCA(:,:,:,4),raySampleGrid2(:,1,:,:),raySampleGrid2(:,2,:,:),raySampleGrid2(:,3,:,:), method, 0));
            end
            
            rayColor(:,:,:,1) = squeeze(interp3(volCA(:,:,:,1),raySampleGrid(:,1,:,:),raySampleGrid(:,2,:,:),raySampleGrid(:,3,:,:), method, 0));
            rayColor(:,:,:,2) = squeeze(interp3(volCA(:,:,:,2),raySampleGrid(:,1,:,:),raySampleGrid(:,2,:,:),raySampleGrid(:,3,:,:), method, 0));
            rayColor(:,:,:,3) = squeeze(interp3(volCA(:,:,:,3),raySampleGrid(:,1,:,:),raySampleGrid(:,2,:,:),raySampleGrid(:,3,:,:), method, 0));
            
            %disp(['Sample Chunk: ' num2str(x)]);
            set(textDisp, 'string', ['Render Chunk ' num2str(chunk) '/' num2str(totalChunks)]);
            chunk = chunk+1;
            pause(.001);
            
            rayAlpha(rayAlpha<0) = 0;
            rayAlpha(rayAlpha>1) = 1;
            rayColor(rayColor<0) = 0;
            rayColor(rayColor>1) = 1;
            if shadingLevel>0
                rayAlpha2(rayAlpha<0) = 0;
                rayAlpha2(rayAlpha>1) = 1;
            end

            
            % Transparency Adjust
            %rayAlpha(rayAlpha<.005) = 0;
            %rayAlpha = rayAlpha.^(1/50); 
            
            % Find the alpha values corrected for passing through
            % previous transparent material
            runningAlpha = zeros(sampleNum, sampleChunk, sampleChunk, 1);
            runningAlpha(1,:,:,1) = rayAlpha(1,:,:);
            
            runningAlphaTotal = zeros(sampleNum, sampleChunk, sampleChunk, 1);
            runningAlphaTotal(1,:,:,1) = rayAlpha(1,:,:);
            
            lightGrad = [];
            if shadingLevel>0
                lightGrad = ((rayAlpha-rayAlpha2)*shadingCont+.5)/2;
                lightGrad(lightGrad<0) = 0;
                lightGrad(lightGrad>1) = 1;
                lightGrad = lightGrad*shadingLevel;
                max(lightGrad(:))
            end
            
            for s = 2:(sampleNum)
                
                % Find current running
                runningAlpha(s,:,:,1) =  (1-runningAlphaTotal(1,:,:,1)).*rayAlpha(s,:,:);  
                
                %Update current total
                runningAlphaTotal(1,:,:,1) = runningAlphaTotal(1,:,:,1)+runningAlpha(s,:,:,1);
            end
            
            % this should never excede 1
            sumAlphaCheck = sum(runningAlpha,1);
            if(max(sumAlphaCheck(:))>1)
                disp('alpha Sum check problem')
            end
            
            if shadingLevel == 0
                fullImage(x1:x2,y1:y2,1) = squeeze( sum( rayColor(:,:,:,1).*runningAlpha(:,:,:,1), 1));
                fullImage(x1:x2,y1:y2,2) = squeeze( sum( rayColor(:,:,:,2).*runningAlpha(:,:,:,1), 1));
                fullImage(x1:x2,y1:y2,3) = squeeze( sum( rayColor(:,:,:,3).*runningAlpha(:,:,:,1), 1));
            else
                fullImage(x1:x2,y1:y2,1) = squeeze( sum( rayColor(:,:,:,1).*runningAlpha(:,:,:,1).*((1-shadingLevel)+lightGrad), 1));
                fullImage(x1:x2,y1:y2,2) = squeeze( sum( rayColor(:,:,:,2).*runningAlpha(:,:,:,1).*((1-shadingLevel)+lightGrad), 1));
                fullImage(x1:x2,y1:y2,3) = squeeze( sum( rayColor(:,:,:,3).*runningAlpha(:,:,:,1).*((1-shadingLevel)+lightGrad), 1));
            end
            
            
            
            % Display current image
            displayImg = permute(fullImage, [2 1 3]);
            %displayImg = displayImg/max(displayImg(:));

            %max(displayImg(:))
            
            image(displayImg, 'Parent', viewAxis);
            set(viewAxis, 'Xdir', 'normal', 'ydir', 'normal');
            
            clear('rayColor', 'displayImg');
            pause(.001);
            
            
            
        end
    end
    clear('rayAlpha', 'raySampleGrid','raySampleGrid2', 'DataStruct')
    set(textDisp, 'visible', 'off');
    

    
    function [phiVec] = getPixelForVec(x, y)
        xn = (x-rez/2)/rez;
        yn = (y-rez/2)/rez;
        
        xAngle = camAngle*xn/180*pi;
        yAngle = camAngle*yn/180*pi;
        
        % using degree and asamuthe model
        thetaVec = cos(xAngle)*camFor   + sin(xAngle)*camRight;
        phiVec   = cos(yAngle)*thetaVec + sin(yAngle)*camUp;
        
        pForVec = phiVec/norm(phiVec);
    
    end


end

